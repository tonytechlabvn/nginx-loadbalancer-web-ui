import { Upstream, VIP } from '../types';

const generateNginxConfig = (upstreams: Upstream[], vips: VIP[]): string => {
  let config = `# This configuration was generated by the Nginx Config Assistant\n# ${new Date().toUTCString()}\n\n`;

  // Upstreams
  if (upstreams.length > 0) {
    config += `##################################\n`;
    config += `## Upstream Server Pools\n`;
    config += `##################################\n\n`;
    upstreams.forEach(up => {
      config += `upstream ${up.name} {\n`;
      if (up.method && up.method !== 'round_robin') {
        config += `    ${up.method};\n`;
      }
      up.servers.forEach(s => {
        config += `    server ${s.address}:${s.port};\n`;
      });
      if (up.healthCheck) {
        config += `\n    # Health checks require the 'ngx_http_upstream_health_check_module'\n`;
        config += `    health_check;\n`;
      }
      config += `}\n\n`;
    });
  }

  // VIPs (Server Blocks)
  if (vips.length > 0) {
    config += `##################################\n`;
    config += `## Virtual Servers (VIPs)\n`;
    config += `##################################\n\n`;
    vips.forEach(vip => {
      if (vip.ssl) {
        // HTTP to HTTPS redirect server
        config += `# Redirect all HTTP traffic to HTTPS for ${vip.serverName}\n`;
        config += `server {\n`;
        config += `    listen 80;\n`;
        config += `    server_name ${vip.serverName};\n`;
        config += `    return 301 https://$host$request_uri;\n`;
        config += `}\n\n`;

        // HTTPS server
        config += `# HTTPS server for ${vip.serverName}\n`;
        config += `server {\n`;
        config += `    listen 443 ssl http2;\n`;
        config += `    server_name ${vip.serverName};\n\n`;

        // SSL Config
        const certPath = vip.sslCert || `/etc/nginx/ssl/${vip.serverName}.crt`;
        const keyPath = vip.sslKey || `/etc/nginx/ssl/${vip.serverName}.key`;
        config += `    # SSL Certificate\n`;
        config += `    ssl_certificate ${certPath};\n`;
        config += `    ssl_certificate_key ${keyPath};\n\n`;

        // Modern SSL Security
        config += `    # Modern SSL Security Settings\n`;
        config += `    ssl_protocols TLSv1.2 TLSv1.3;\n`;
        config += `    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';\n`;
        config += `    ssl_prefer_server_ciphers on;\n\n`;
        
        // Location Block with Proxy Pass
        config += `    location / {\n`;
        config += `        proxy_pass http://${vip.upstreamName};\n`;
        config += `        proxy_set_header Host $host;\n`;
        config += `        proxy_set_header X-Real-IP $remote_addr;\n`;
        config += `        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n`;
        config += `        proxy_set_header X-Forwarded-Proto $scheme;\n`;
        config += `    }\n`;
        config += `}\n\n`;

      } else {
        // Standard HTTP server
        config += `# HTTP server for ${vip.serverName}\n`;
        config += `server {\n`;
        config += `    listen ${vip.listenPort};\n`;
        config += `    server_name ${vip.serverName};\n\n`;
        
        config += `    location / {\n`;
        config += `        proxy_pass http://${vip.upstreamName};\n`;
        config += `        proxy_set_header Host $host;\n`;
        config += `        proxy_set_header X-Real-IP $remote_addr;\n`;
        config += `        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n`;
        config += `        proxy_set_header X-Forwarded-Proto $scheme;\n`;
        config += `    }\n`;
        config += `}\n\n`;
      }
    });
  }

  return config.trim();
};

export { generateNginxConfig };
